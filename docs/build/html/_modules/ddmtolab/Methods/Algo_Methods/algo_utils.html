

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ddmtolab.Methods.Algo_Methods.algo_utils &mdash; DDMTOLab 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            DDMTOLab
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../demos.html">Demos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../methods.html">Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../problems.html">Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">DDMTOLab</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">ddmtolab.Methods.Algo_Methods.algo_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for ddmtolab.Methods.Algo_Methods.algo_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This script contains commonly used components for implementing algorithms.</span>

<span class="sd">Author: Jiangtao Shen</span>
<span class="sd">Email: j.shen5@exeter.ac.uk</span>
<span class="sd">Date: 2025.10.18</span>
<span class="sd">Version: 1.0</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pickle</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">asdict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">copy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>


<div class="viewcode-block" id="Results">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.Results">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Results</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Container for optimization results.</span>

<span class="sd">    :no-index:</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    best_decs : List[np.ndarray]</span>
<span class="sd">        Best decision variables for each task</span>
<span class="sd">    best_objs : List[np.ndarray]</span>
<span class="sd">        Best objective values for each task</span>
<span class="sd">    all_decs : List[List[np.ndarray]]</span>
<span class="sd">        Decision variables history for all tasks across generations</span>
<span class="sd">    all_objs : List[List[np.ndarray]]</span>
<span class="sd">        Objective values history for all tasks across generations</span>
<span class="sd">    runtime : float</span>
<span class="sd">        Total runtime in seconds</span>
<span class="sd">    max_nfes : List[int]</span>
<span class="sd">        Maximum function evaluations per task</span>
<span class="sd">    best_cons : Optional[List[np.ndarray]]</span>
<span class="sd">        Best constraint values for each task (None if unconstrained)</span>
<span class="sd">    all_cons : Optional[List[List[np.ndarray]]]</span>
<span class="sd">        Constraint values history for all tasks (None if unconstrained)</span>
<span class="sd">    bounds : Optional[List[np.ndarray]]</span>
<span class="sd">        Bounds for each task, where each element is a 2D array with shape (2, dim)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">best_decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">best_objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="n">all_decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="n">all_objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
    <span class="n">runtime</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">max_nfes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">best_cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">all_cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="build_save_results">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.build_save_results">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_save_results</span><span class="p">(</span>
        <span class="n">all_decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">all_objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">runtime</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">max_nfes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">all_cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">save_data</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Results</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract best solutions, build results, and optionally save to file.</span>

<span class="sd">    Automatically detects single-objective vs multi-objective tasks:</span>

<span class="sd">    - Single-objective (n_objs=1): returns the best individual</span>
<span class="sd">    - Multi-objective (n_objs&gt;1): returns the entire final population (Pareto front)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_decs : List[List[np.ndarray]]</span>
<span class="sd">        Decision variables history for all tasks.</span>
<span class="sd">        all_decs[i][g] has shape (n_samples, dim) for task i at generation g.</span>
<span class="sd">    all_objs : List[List[np.ndarray]]</span>
<span class="sd">        Objective values history for all tasks.</span>
<span class="sd">        all_objs[i][g] has shape (n_samples, n_objs) for task i at generation g.</span>
<span class="sd">    runtime : float</span>
<span class="sd">        Total runtime in seconds</span>
<span class="sd">    max_nfes : List[int]</span>
<span class="sd">        Maximum function evaluations per task</span>
<span class="sd">    all_cons : List[List[np.ndarray]], optional</span>
<span class="sd">        Constraint values history for all tasks (default: None)</span>
<span class="sd">    bounds : List[Tuple[np.ndarray, np.ndarray]], optional</span>
<span class="sd">        Bounds (lower, upper) for each task (default: None)</span>
<span class="sd">    save_path : str, optional</span>
<span class="sd">        Directory path where the results will be saved (default: None)</span>
<span class="sd">    filename : str, optional</span>
<span class="sd">        Name of the output file without extension (default: None)</span>
<span class="sd">    save_data : bool, optional</span>
<span class="sd">        Whether to save the data to file (default: True)</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Additional data to include in the saved file</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : Results</span>
<span class="sd">        Results object containing best solutions and optimization history</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_decs</span><span class="p">)</span>

    <span class="n">best_decs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">best_cons</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">all_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="n">last_gen_objs</span> <span class="o">=</span> <span class="n">all_objs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">last_gen_decs</span> <span class="o">=</span> <span class="n">all_decs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">last_gen_cons</span> <span class="o">=</span> <span class="n">all_cons</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">all_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="n">n_objs</span> <span class="o">=</span> <span class="n">last_gen_objs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">n_objs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">last_gen_objs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">best_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_objs</span><span class="p">[</span><span class="n">best_idx</span><span class="p">])</span>
            <span class="n">best_decs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_decs</span><span class="p">[</span><span class="n">best_idx</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">all_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_cons</span><span class="p">[</span><span class="n">best_idx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_objs</span><span class="p">)</span>
            <span class="n">best_decs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_decs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">all_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">best_cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last_gen_cons</span><span class="p">)</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span>
        <span class="n">best_decs</span><span class="o">=</span><span class="n">best_decs</span><span class="p">,</span>
        <span class="n">best_objs</span><span class="o">=</span><span class="n">best_objs</span><span class="p">,</span>
        <span class="n">all_decs</span><span class="o">=</span><span class="n">all_decs</span><span class="p">,</span>
        <span class="n">all_objs</span><span class="o">=</span><span class="n">all_objs</span><span class="p">,</span>
        <span class="n">runtime</span><span class="o">=</span><span class="n">runtime</span><span class="p">,</span>
        <span class="n">max_nfes</span><span class="o">=</span><span class="n">max_nfes</span><span class="p">,</span>
        <span class="n">best_cons</span><span class="o">=</span><span class="n">best_cons</span><span class="p">,</span>
        <span class="n">all_cons</span><span class="o">=</span><span class="n">all_cons</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Save results to file if path and filename are provided</span>
    <span class="k">if</span> <span class="n">save_data</span> <span class="ow">and</span> <span class="n">save_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">.pkl&quot;</span><span class="p">)</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="n">asdict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
        <span class="n">data_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="get_algorithm_information">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.get_algorithm_information">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_algorithm_information</span><span class="p">(</span><span class="n">algorithm_class</span><span class="p">:</span> <span class="nb">type</span><span class="p">,</span> <span class="n">print_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get algorithm information from any algorithm class.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    algorithm_class : type</span>
<span class="sd">        Algorithm class with &#39;algorithm_information&#39; attribute</span>
<span class="sd">    print_info : bool, optional</span>
<span class="sd">        Whether to print the information (default: True)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    algo_info : dict</span>
<span class="sd">        Algorithm information dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">algorithm_class</span><span class="p">,</span> <span class="s1">&#39;algorithm_information&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">algorithm_class</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not have &#39;algorithm_information&#39; attribute&quot;</span><span class="p">)</span>

    <span class="n">algo_info</span> <span class="o">=</span> <span class="n">algorithm_class</span><span class="o">.</span><span class="n">algorithm_information</span>
    <span class="n">algo_name</span> <span class="o">=</span> <span class="n">algorithm_class</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">information</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">algo_info</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="n">info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;ü§ñÔ∏è </span><span class="si">{</span><span class="n">algo_name</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2">Algorithm Information:</span><span class="se">\n</span><span class="si">{</span><span class="n">information</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">if</span> <span class="n">print_info</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">algo_info</span></div>



<div class="viewcode-block" id="init_history">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.init_history">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">init_history</span><span class="p">(</span>
        <span class="n">decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]],</span>
<span class="nb">tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize history storage for populations across generations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    decs : List[np.ndarray]</span>
<span class="sd">        Initial decision variables for each task.</span>
<span class="sd">        decs[i] has shape (n_samples, dim) for task i.</span>
<span class="sd">    objs : List[np.ndarray]</span>
<span class="sd">        Initial objective values for each task.</span>
<span class="sd">        objs[i] has shape (n_samples, n_objs) for task i.</span>
<span class="sd">    cons : List[np.ndarray], optional</span>
<span class="sd">        Initial constraint values for each task (default: None).</span>
<span class="sd">        cons[i] has shape (n_samples, n_cons) for task i.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_decs : List[List[np.ndarray]]</span>
<span class="sd">        History storage for decision variables</span>
<span class="sd">    all_objs : List[List[np.ndarray]]</span>
<span class="sd">        History storage for objective values</span>
<span class="sd">    all_cons : List[List[np.ndarray]], optional</span>
<span class="sd">        History storage for constraint values (only returned if cons is not None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_decs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">decs</span><span class="p">]</span>
    <span class="n">all_objs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">o</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">all_cons</span> <span class="o">=</span> <span class="p">[[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cons</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">all_decs</span><span class="p">,</span> <span class="n">all_objs</span><span class="p">,</span> <span class="n">all_cons</span>

    <span class="k">return</span> <span class="n">all_decs</span><span class="p">,</span> <span class="n">all_objs</span></div>



<div class="viewcode-block" id="vstack_groups">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.vstack_groups">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vstack_groups</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="kc">None</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack population arrays vertically.</span>

<span class="sd">    Supports both single arrays (list of arrays) and tuples with variable number of arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : Union[List[np.ndarray], tuple[np.ndarray, ...], None]</span>
<span class="sd">        Variable number of arguments, each can be:</span>

<span class="sd">        - List of arrays to stack vertically</span>
<span class="sd">        - Tuple of arrays (any number) to stack</span>
<span class="sd">        - None (will be skipped)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Stacked array if single input, or list of stacked arrays if multiple inputs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">results</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="append_history">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.append_history">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">append_history</span><span class="p">(</span><span class="o">*</span><span class="n">pairs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append current generation data to history storage.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *pairs : tuple</span>
<span class="sd">        Alternating pairs of (history_list, current_data).</span>

<span class="sd">        - history_list: List to store historical data</span>
<span class="sd">        - current_data: Either a single np.ndarray (single task) or List[np.ndarray] (multi-task)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : tuple</span>
<span class="sd">        All updated history lists (all_1, all_2, ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pairs</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">all_list</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pairs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Single task: input is a single array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">all_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="c1"># Multi-task: input is a list of arrays</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
                <span class="n">all_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">all_list</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<div class="viewcode-block" id="select_by_index">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.select_by_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">select_by_index</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select rows from arrays by index.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : np.ndarray</span>
<span class="sd">        Indices to select, shape (n_selected,)</span>
<span class="sd">    *arrays : np.ndarray or None</span>
<span class="sd">        Variable number of arrays to select from.</span>
<span class="sd">        Each array has shape (n_samples,) or (n_samples, dim).</span>
<span class="sd">        None values are passed through unchanged.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    results : Union[np.ndarray, List[Optional[np.ndarray]]]</span>
<span class="sd">        Selected array if single input, or list of selected arrays if multiple inputs.</span>
<span class="sd">        None inputs return None in the corresponding position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Ëøô‰∏ÄË°åÂøÖÈ°ªÂú® arr.ndim ‰πãÂâçÊ£ÄÊü•</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:])</span>

    <span class="k">return</span> <span class="n">results</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">results</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="par_list">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.par_list">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">par_list</span><span class="p">(</span><span class="n">par</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="n">n_tasks</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a parameter to a list for multi-task scenarios.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    par : Union[int, List[int]]</span>
<span class="sd">        Parameter value(s) - can be a single integer or a list</span>
<span class="sd">    n_tasks : int</span>
<span class="sd">        Number of tasks</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    par_per_task : List[int]</span>
<span class="sd">        List of parameter values, one for each task.</span>

<span class="sd">        - If par is int: returns [par, par, ..., par] (n_tasks times)</span>
<span class="sd">        - If par is list: returns the list as is</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">par_per_task</span> <span class="o">=</span> <span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_tasks</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">par_per_task</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">par_per_task</span></div>



<div class="viewcode-block" id="reorganize_initial_data">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.reorganize_initial_data">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">reorganize_initial_data</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">nt</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">n_initial_per_task</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">interval</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reorganize initial data by task and number of initial points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : List[np.ndarray]</span>
<span class="sd">        Original data list, where data[i] is the data array for task i</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of tasks</span>
<span class="sd">    n_initial_per_task : List[int]</span>
<span class="sd">        List of number of initial points for each task</span>
<span class="sd">    interval : int, optional</span>
<span class="sd">        Interval for selecting points. Default is 1.</span>
<span class="sd">        - interval=1: 1, 2, 3, 4, ... points</span>
<span class="sd">        - interval=2: 2, 4, 6, 8, ... points</span>
<span class="sd">        - interval=k: k, 2k, 3k, 4k, ... (plus remaining points if not divisible)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_data : List[List[np.ndarray]]</span>
<span class="sd">        Reorganized data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="n">task_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n_initial_per_task</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="c1"># Store points at each interval</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
            <span class="n">task_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="c1"># Add remaining points if not divisible</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">interval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">task_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">all_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">task_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_data</span></div>



<div class="viewcode-block" id="initialization">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.initialization">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">initialization</span><span class="p">(</span>
        <span class="n">problem</span><span class="p">:</span> <span class="s1">&#39;MTOP&#39;</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;random&#39;</span><span class="p">,</span>
        <span class="n">the_same</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize decision variable matrices for multiple tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : MTOP</span>
<span class="sd">        An instance of the MTOP class</span>
<span class="sd">    n : Union[int, List[int]]</span>
<span class="sd">        Number of samples per task.</span>

<span class="sd">        - If int: same number of samples for all tasks</span>
<span class="sd">        - If list: number of samples for each task, e.g., [30, 50]</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Sampling method: &#39;random&#39; or &#39;lhs&#39; (default: &#39;random&#39;)</span>
<span class="sd">    the_same : bool, optional</span>
<span class="sd">        If True, all tasks share the same sample points (default: False).</span>
<span class="sd">        For tasks with different dimensions, samples are generated in the</span>
<span class="sd">        maximum dimension and then truncated to each task&#39;s dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    decs : List[np.ndarray]</span>
<span class="sd">        List of decision variable matrices for each task.</span>
<span class="sd">        decs[i] has shape (n_i, d_i) for task i.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">dims</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">n_tasks</span>

    <span class="c1"># Handle n: convert to array if it&#39;s an integer</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">n_per_task</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">nt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n_per_task</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n_per_task</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of n array (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">n_per_task</span><span class="p">)</span><span class="si">}</span><span class="s2">) must match number of tasks (</span><span class="si">{</span><span class="n">nt</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="n">decs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">the_same</span><span class="p">:</span>
        <span class="c1"># Generate samples in the maximum dimension and truncate to each task&#39;s dimension</span>
        <span class="n">max_dim</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">max_n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n_per_task</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;lhs&#39;</span><span class="p">:</span>
            <span class="c1"># Generate LHS samples in maximum dimension</span>
            <span class="n">matrix_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">max_n</span><span class="p">,</span> <span class="n">max_dim</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_dim</span><span class="p">):</span>
                <span class="n">intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                <span class="n">matrix_full</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Generate random samples in maximum dimension</span>
            <span class="n">matrix_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="n">max_dim</span><span class="p">)</span>

        <span class="c1"># Truncate to each task&#39;s sample size and dimension</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">n_per_task</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">decs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix_full</span><span class="p">[:</span><span class="n">n_samples</span><span class="p">,</span> <span class="p">:</span><span class="n">dim</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Generate independent samples for each task</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">n_per_task</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;lhs&#39;</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                    <span class="n">intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">samples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">intervals</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
                    <span class="n">matrix</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">samples</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">decs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">decs</span></div>



<div class="viewcode-block" id="evaluation">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.evaluation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">evaluation</span><span class="p">(</span>
        <span class="n">problem</span><span class="p">,</span>
        <span class="n">decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">unified</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">eval_objectives</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">eval_constraints</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate a list of decision variable matrices on multiple tasks.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : MTOP</span>
<span class="sd">        An instance of the MTOP class.</span>
<span class="sd">    decs : list of ndarray</span>
<span class="sd">        List of decision variable matrices for each task, shape [n, d_i], scaled in [0,1].</span>
<span class="sd">    unified : bool, optional</span>
<span class="sd">        If True, pad objectives to m_max and constraints to c_max. Default False.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Value used for padding in unified mode. Default 0.0.</span>
<span class="sd">    eval_objectives : bool or list, optional</span>
<span class="sd">        - True: evaluate all objectives for all tasks (default)</span>
<span class="sd">        - False: skip objective evaluation for all tasks</span>
<span class="sd">        - List: per-task specification, each element can be:</span>

<span class="sd">            - True/False: evaluate all/none</span>
<span class="sd">            - int: evaluate only the i-th objective</span>
<span class="sd">            - List[int]: evaluate specified objectives</span>
<span class="sd">    eval_constraints : bool or list, optional</span>
<span class="sd">        - True: evaluate all constraints for all tasks (default)</span>
<span class="sd">        - False: skip constraint evaluation for all tasks</span>
<span class="sd">        - List: per-task specification, same format as eval_objectives</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    objs : list of ndarray</span>
<span class="sd">        List of objective value matrices for each task.</span>

<span class="sd">        - Normal mode: shape [n, m_i] or [n, len(selected)]</span>
<span class="sd">        - Unified mode: shape [n, m_max]</span>
<span class="sd">    cons : list of ndarray</span>
<span class="sd">        List of constraint value matrices for each task.</span>

<span class="sd">        - Normal mode: shape [n, c_i] or [n, 1] if no constraints</span>
<span class="sd">        - Unified mode: shape [n, c_max]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">n_tasks</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">bounds</span>

    <span class="c1"># Expand eval_objectives/eval_constraints to per-task lists</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_objectives</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_objectives</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">:</span>
        <span class="n">obj_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_objectives</span><span class="p">]</span> <span class="o">*</span> <span class="n">nt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj_modes</span> <span class="o">=</span> <span class="n">eval_objectives</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">eval_constraints</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">eval_constraints</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nt</span><span class="p">:</span>
        <span class="n">con_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">eval_constraints</span><span class="p">]</span> <span class="o">*</span> <span class="n">nt</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">con_modes</span> <span class="o">=</span> <span class="n">eval_constraints</span>

    <span class="c1"># Get max dimensions for unified mode</span>
    <span class="n">m_max</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">m_max</span> <span class="k">if</span> <span class="n">unified</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">c_max</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">c_max</span> <span class="k">if</span> <span class="n">unified</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="c1"># Scale decision variables from [0,1] to real bounds</span>
        <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">decs_real</span> <span class="o">=</span> <span class="n">decs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="n">lb</span>

        <span class="c1"># Evaluate task</span>
        <span class="n">objectives</span><span class="p">,</span> <span class="n">constraints</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">evaluate_task</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">decs_real</span><span class="p">,</span>
            <span class="n">eval_objectives</span><span class="o">=</span><span class="n">obj_modes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">eval_constraints</span><span class="o">=</span><span class="n">con_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">n_samples</span> <span class="o">=</span> <span class="n">decs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_con</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">get_n_constraints</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Handle no constraints case</span>
        <span class="k">if</span> <span class="n">con_modes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">n_con</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Apply unified mode padding</span>
        <span class="k">if</span> <span class="n">unified</span><span class="p">:</span>
            <span class="n">objectives</span> <span class="o">=</span> <span class="n">_pad_to_size</span><span class="p">(</span><span class="n">objectives</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">_pad_to_size</span><span class="p">(</span><span class="n">constraints</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

        <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">objectives</span><span class="p">)</span>
        <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">objs</span><span class="p">,</span> <span class="n">cons</span></div>



<div class="viewcode-block" id="evaluation_single">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.evaluation_single">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">evaluation_single</span><span class="p">(</span>
        <span class="n">problem</span><span class="p">,</span>
        <span class="n">decs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">unified</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">eval_objectives</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">eval_constraints</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluate decision variables on a specific task.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : MTOP</span>
<span class="sd">        An instance of the MTOP class.</span>
<span class="sd">    decs : ndarray</span>
<span class="sd">        Decision variable matrix for the task, shape [n, d], scaled in [0,1].</span>
<span class="sd">    index : int</span>
<span class="sd">        Index of the task to evaluate.</span>
<span class="sd">    unified : bool, optional</span>
<span class="sd">        If True, pad objectives to m_max and constraints to c_max. Default False.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Value used for padding in unified mode. Default 0.0.</span>
<span class="sd">    eval_objectives : bool, int, or list of int, optional</span>
<span class="sd">        - True: evaluate all objectives (default)</span>
<span class="sd">        - False: skip objective evaluation</span>
<span class="sd">        - int: evaluate only the i-th objective</span>
<span class="sd">        - List[int]: evaluate specified objectives</span>
<span class="sd">    eval_constraints : bool, int, or list of int, optional</span>
<span class="sd">        - True: evaluate all constraints (default)</span>
<span class="sd">        - False: skip constraint evaluation</span>
<span class="sd">        - int: evaluate only the i-th constraint</span>
<span class="sd">        - List[int]: evaluate specified constraints</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    objs : ndarray</span>
<span class="sd">        Objective values for the task.</span>

<span class="sd">        - Normal mode: shape [n, m] or [n, len(selected)]</span>
<span class="sd">        - Unified mode: shape [n, m_max]</span>
<span class="sd">    cons : ndarray</span>
<span class="sd">        Constraint values for the task.</span>

<span class="sd">        - Normal mode: shape [n, c] or [n, 1] if no constraints</span>
<span class="sd">        - Unified mode: shape [n, c_max]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">decs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">decs</span><span class="p">)</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Scale decision variables from [0,1] to real bounds</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">bounds</span>
    <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">decs_real</span> <span class="o">=</span> <span class="n">decs</span> <span class="o">*</span> <span class="p">(</span><span class="n">ub</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">+</span> <span class="n">lb</span>

    <span class="c1"># Evaluate task</span>
    <span class="n">objs</span><span class="p">,</span> <span class="n">cons</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">evaluate_task</span><span class="p">(</span>
        <span class="n">index</span><span class="p">,</span> <span class="n">decs_real</span><span class="p">,</span>
        <span class="n">eval_objectives</span><span class="o">=</span><span class="n">eval_objectives</span><span class="p">,</span>
        <span class="n">eval_constraints</span><span class="o">=</span><span class="n">eval_constraints</span>
    <span class="p">)</span>

    <span class="n">n_con</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">get_n_constraints</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="c1"># Handle no constraints case</span>
    <span class="k">if</span> <span class="n">eval_constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">n_con</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">cons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Apply unified mode padding</span>
    <span class="k">if</span> <span class="n">unified</span><span class="p">:</span>
        <span class="n">m_max</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">m_max</span>
        <span class="n">c_max</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">c_max</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="n">_pad_to_size</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="n">cons</span> <span class="o">=</span> <span class="n">_pad_to_size</span><span class="p">(</span><span class="n">cons</span><span class="p">,</span> <span class="n">c_max</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">objs</span><span class="p">,</span> <span class="n">cons</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_pad_to_size</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">target_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pad array to target size along axis 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : np.ndarray</span>
<span class="sd">        Input array to pad, shape (n_samples, dim)</span>
<span class="sd">    target_size : int</span>
<span class="sd">        Target size for axis 1</span>
<span class="sd">    fill_value : float</span>
<span class="sd">        Value to use for padding</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padded_arr : np.ndarray</span>
<span class="sd">        Padded array, shape (n_samples, target_size).</span>
<span class="sd">        Returns original array if already at or above target size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">target_size</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pad_width</span> <span class="o">=</span> <span class="n">target_size</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>


<div class="viewcode-block" id="crossover">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.crossover">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crossover</span><span class="p">(</span>
        <span class="n">par_dec1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">par_dec2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform Simulated Binary Crossover (SBX) on two decision vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    par_dec1 : np.ndarray</span>
<span class="sd">        First parent decision vector, values scaled in [0, 1], shape (dim,)</span>
<span class="sd">    par_dec2 : np.ndarray</span>
<span class="sd">        Second parent decision vector, values scaled in [0, 1], shape (dim,)</span>
<span class="sd">    mu : float, optional</span>
<span class="sd">        Distribution index for crossover (default: 2)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    off_dec1 : np.ndarray</span>
<span class="sd">        First offspring decision vector, values clipped to [0, 1], shape (dim,)</span>
<span class="sd">    off_dec2 : np.ndarray</span>
<span class="sd">        Second offspring decision vector, values clipped to [0, 1], shape (dim,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">par_dec1</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="mf">0.5</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">mask</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">beta</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]))</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">beta</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
    <span class="n">beta</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">off_dec1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">par_dec1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">par_dec2</span><span class="p">)</span>
    <span class="n">off_dec2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">par_dec2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">par_dec1</span><span class="p">)</span>
    <span class="n">off_dec1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">off_dec1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">off_dec2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">off_dec2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">off_dec1</span><span class="p">,</span> <span class="n">off_dec2</span></div>



<div class="viewcode-block" id="mutation">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.mutation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mutation</span><span class="p">(</span><span class="n">dec</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform polynomial mutation on a decision vector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dec : np.ndarray</span>
<span class="sd">        Parent decision vector, values scaled in [0, 1], shape (dim,)</span>
<span class="sd">    mu : float, optional</span>
<span class="sd">        Distribution index for mutation (default: 5)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mutated_dec : np.ndarray</span>
<span class="sd">        Mutated decision vector, values clipped to [0, 1], shape (dim,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="n">mutated_dec</span> <span class="o">=</span> <span class="n">dec</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">prob_m</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">d</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">prob_m</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">u</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">u</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mutated_dec</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">**</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">mutated_dec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">mutated_dec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">**</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">mu</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">mutated_dec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span>
    <span class="n">mutated_dec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">mutated_dec</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mutated_dec</span></div>



<div class="viewcode-block" id="ga_generation">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.ga_generation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ga_generation</span><span class="p">(</span><span class="n">parents</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">muc</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mum</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate offspring population using genetic algorithm operators.</span>

<span class="sd">    Applies simulated binary crossover (SBX) and polynomial mutation</span>
<span class="sd">    to create offspring from parent population.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parents : np.ndarray</span>
<span class="sd">        Parent population, shape (n, d)</span>
<span class="sd">    muc : float</span>
<span class="sd">        Distribution index for crossover</span>
<span class="sd">    mum : float</span>
<span class="sd">        Distribution index for mutation</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offdecs : np.ndarray</span>
<span class="sd">        Offspring decision variables, shape (n, d)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">parents</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">offdecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="n">num_pairs</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># Process pairs</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_pairs</span><span class="p">):</span>
        <span class="n">offdec1</span><span class="p">,</span> <span class="n">offdec2</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">parents</span><span class="p">[</span><span class="n">num_pairs</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">mu</span><span class="o">=</span><span class="n">muc</span><span class="p">)</span>
        <span class="n">offdec1</span> <span class="o">=</span> <span class="n">mutation</span><span class="p">(</span><span class="n">offdec1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mum</span><span class="p">)</span>
        <span class="n">offdec2</span> <span class="o">=</span> <span class="n">mutation</span><span class="p">(</span><span class="n">offdec2</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mum</span><span class="p">)</span>
        <span class="n">offdecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">offdecs</span><span class="p">,</span> <span class="n">offdec1</span><span class="p">,</span> <span class="n">offdec2</span><span class="p">))</span>

    <span class="c1"># Handle odd number of parents</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">last_parent</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">random_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">offdec1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">last_parent</span><span class="p">,</span> <span class="n">parents</span><span class="p">[</span><span class="n">random_idx</span><span class="p">,</span> <span class="p">:],</span> <span class="n">mu</span><span class="o">=</span><span class="n">muc</span><span class="p">)</span>
        <span class="n">offdec1</span> <span class="o">=</span> <span class="n">mutation</span><span class="p">(</span><span class="n">offdec1</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mum</span><span class="p">)</span>
        <span class="n">offdecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">offdecs</span><span class="p">,</span> <span class="n">offdec1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">offdecs</span></div>



<div class="viewcode-block" id="de_generation">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.de_generation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">de_generation</span><span class="p">(</span><span class="n">parents</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">F</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">CR</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate offspring for a population using Differential Evolution (DE).</span>

<span class="sd">    Uses DE/rand/1/bin strategy: random base vector, one difference vector,</span>
<span class="sd">    and binomial crossover.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parents : np.ndarray</span>
<span class="sd">        Array of parent solutions, shape (n, d)</span>
<span class="sd">    F : float</span>
<span class="sd">        Differential weight (mutation scale factor)</span>
<span class="sd">    CR : float</span>
<span class="sd">        Crossover rate in [0, 1] for binomial crossover</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    offdecs : np.ndarray</span>
<span class="sd">        Offspring array, shape (n, d), clipped to [0, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">parents</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">offdecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># Choose 3 distinct indices != j</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span> <span class="o">!=</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">x_1</span><span class="p">,</span> <span class="n">x_2</span><span class="p">,</span> <span class="n">x_3</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">parents</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>

        <span class="c1"># DE mutation (rand/1)</span>
        <span class="n">mutant</span> <span class="o">=</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">F</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_2</span> <span class="o">-</span> <span class="n">x_3</span><span class="p">)</span>

        <span class="c1"># Binomial crossover (ensure at least one gene from mutant)</span>
        <span class="n">trial</span> <span class="o">=</span> <span class="n">mutant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">replace_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">CR</span>
        <span class="n">replace_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">trial</span><span class="p">[</span><span class="n">replace_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">replace_mask</span><span class="p">]</span>

        <span class="c1"># Clip to bounds</span>
        <span class="n">offdecs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">trial</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">offdecs</span></div>



<div class="viewcode-block" id="space_transfer">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.space_transfer">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">space_transfer</span><span class="p">(</span>
        <span class="n">problem</span><span class="p">:</span> <span class="s1">&#39;MTOP&#39;</span><span class="p">,</span>
        <span class="n">decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">objs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;real&#39;</span><span class="p">,</span>
        <span class="n">padding</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;zero&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
<span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
<span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transfer decision variables, objectives, and constraints between unified and real spaces.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    problem : MTOP</span>
<span class="sd">        An instance of the MTOP class containing task configuration</span>
<span class="sd">    decs : List[np.ndarray]</span>
<span class="sd">        List of decision variable matrices.</span>

<span class="sd">        - Real space: decs[i] has shape (n_i, d_i)</span>
<span class="sd">        - Unified space: decs[i] has shape (n_i, d_max)</span>
<span class="sd">    objs : List[np.ndarray], optional</span>
<span class="sd">        List of objective value matrices (default: None).</span>

<span class="sd">        - Real space: objs[i] has shape (n_i, m_i)</span>
<span class="sd">        - Unified space: objs[i] has shape (n_i, m_max)</span>
<span class="sd">    cons : List[np.ndarray], optional</span>
<span class="sd">        List of constraint value matrices (default: None).</span>

<span class="sd">        - Real space: cons[i] has shape (n_i, c_i)</span>
<span class="sd">        - Unified space: cons[i] has shape (n_i, c_max)</span>
<span class="sd">    type : str, optional</span>
<span class="sd">        Transfer type (default: &#39;real&#39;):</span>

<span class="sd">        - &#39;uni&#39;: Pad matrices with zeros or random values to the maximum dimension (Unified Space)</span>
<span class="sd">        - &#39;real&#39;: Truncate matrices back to their original dimensions (Real Space)</span>
<span class="sd">    padding : str, optional</span>
<span class="sd">        Padding strategy when type=&#39;uni&#39; (default: &#39;zero&#39;):</span>

<span class="sd">        - &#39;zero&#39;: Pad with zeros</span>
<span class="sd">        - &#39;random&#39;: Pad with random values uniformly distributed in [0, 1]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_decs : List[np.ndarray]</span>
<span class="sd">        Returned if objs and cons are None</span>
<span class="sd">    (new_decs, new_objs) : tuple[List[np.ndarray], List[np.ndarray]]</span>
<span class="sd">        Returned if objs is provided but cons is None</span>
<span class="sd">    (new_decs, new_objs, new_cons) : tuple[List[np.ndarray], List[np.ndarray], List[np.ndarray]]</span>
<span class="sd">        Returned if both objs and cons are provided</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The padding parameter only affects the &#39;uni&#39; transfer type. When type=&#39;real&#39;,</span>
<span class="sd">    padding is ignored as truncation is performed instead.</span>

<span class="sd">    Fix (2025.12.22): Properly handles cases where some tasks have constraints and others don&#39;t.</span>
<span class="sd">    When ncons[i] = 0, ensures consistent shape (n, c_max) in unified space.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Copy lists to avoid modifying the original input references</span>
    <span class="n">new_decs</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">decs</span><span class="p">]</span>
    <span class="n">new_objs</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objs</span><span class="p">]</span> <span class="k">if</span> <span class="n">objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">new_cons</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cons</span><span class="p">]</span> <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">n_tasks</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">n_tasks</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">dims</span>
    <span class="n">nobjs</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">n_objs</span>
    <span class="n">ncons</span> <span class="o">=</span> <span class="n">problem</span><span class="o">.</span><span class="n">n_cons</span>

    <span class="k">if</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;uni&#39;</span><span class="p">:</span>
        <span class="c1"># Handle Decision Variables (Padding)</span>
        <span class="n">d_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">new_decs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dif</span> <span class="o">=</span> <span class="n">d_max</span> <span class="o">-</span> <span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dif</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                    <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># padding == &#39;zero&#39;</span>
                    <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">))</span>
                <span class="n">new_decs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">new_decs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pad_values</span><span class="p">])</span>

        <span class="c1"># Handle Objectives (Padding)</span>
        <span class="k">if</span> <span class="n">new_objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nobjs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
                <span class="n">n_samples</span> <span class="o">=</span> <span class="n">new_objs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dif</span> <span class="o">=</span> <span class="n">m_max</span> <span class="o">-</span> <span class="n">nobjs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">dif</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                        <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># padding == &#39;zero&#39;</span>
                        <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">))</span>
                    <span class="n">new_objs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">new_objs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pad_values</span><span class="p">])</span>

        <span class="c1"># Handle Constraints (Padding) - FIXED VERSION</span>
        <span class="k">if</span> <span class="n">new_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ncons</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c_max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Only process if at least one task has constraints</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">current_ncons</span> <span class="o">=</span> <span class="n">ncons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># Get current constraint shape</span>
                    <span class="k">if</span> <span class="n">current_ncons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="c1"># Task has no constraints: create matrix with c_max columns filled with zeros</span>
                        <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">c_max</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Task has constraints: pad if necessary</span>
                        <span class="n">dif</span> <span class="o">=</span> <span class="n">c_max</span> <span class="o">-</span> <span class="n">current_ncons</span>
                        <span class="k">if</span> <span class="n">dif</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">padding</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
                                <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>  <span class="c1"># padding == &#39;zero&#39;</span>
                                <span class="n">pad_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">dif</span><span class="p">))</span>
                            <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pad_values</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># No task has constraints: ensure all constraint matrices are empty with same shape</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

    <span class="k">elif</span> <span class="nb">type</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
        <span class="c1"># Handle Decision Variables (Truncation)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
            <span class="n">new_decs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_decs</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="n">dims</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="c1"># Handle Objectives (Truncation)</span>
        <span class="k">if</span> <span class="n">new_objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
                <span class="n">new_objs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_objs</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="n">nobjs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>

        <span class="c1"># Handle Constraints (Truncation) - FIXED VERSION</span>
        <span class="k">if</span> <span class="n">new_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_tasks</span><span class="p">):</span>
                <span class="n">target_ncons</span> <span class="o">=</span> <span class="n">ncons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">target_ncons</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Task should have no constraints: return empty constraint matrix</span>
                    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Task has constraints: truncate to original size</span>
                    <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cons</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="p">:</span><span class="n">target_ncons</span><span class="p">]</span>

    <span class="c1"># Construct return values based on provided arguments</span>
    <span class="k">if</span> <span class="n">objs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cons</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_decs</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_decs</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">objs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_objs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cons</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<div class="viewcode-block" id="nd_sort">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.nd_sort">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">nd_sort</span><span class="p">(</span><span class="n">objs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform non-dominated sorting on a population of objective values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objs : np.ndarray</span>
<span class="sd">        Objective value matrix, shape (n, m)</span>
<span class="sd">    *args : tuple</span>
<span class="sd">        Optional arguments:</span>

<span class="sd">        - (n_sort,): Number of solutions to sort</span>
<span class="sd">        - (cons, n_sort): Constraint matrix and number of solutions to sort</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    front_no : np.ndarray</span>
<span class="sd">        Non-dominated front number for each solution, shape (n,)</span>
<span class="sd">    max_fno : int</span>
<span class="sd">        Maximum front number assigned</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pop_obj</span> <span class="o">=</span> <span class="n">objs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pop_obj</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Parse arguments</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># nd_sort(objs, n_sort)</span>
        <span class="n">n_sort</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># nd_sort(objs, cons, n_sort)</span>
        <span class="n">pop_con</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_sort</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Handle constraints using constrained domination</span>
        <span class="k">if</span> <span class="n">pop_con</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">infeasible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pop_con</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">infeasible</span><span class="p">):</span>
                <span class="n">max_obj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">constraint_violation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop_con</span><span class="p">[</span><span class="n">infeasible</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">pop_obj</span><span class="p">[</span><span class="n">infeasible</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">max_obj</span> <span class="o">+</span> <span class="n">constraint_violation</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid number of arguments. Use nd_sort(objs, n_sort) or nd_sort(objs, cons, n_sort)&quot;</span><span class="p">)</span>

    <span class="c1"># Find unique rows and their locations</span>
    <span class="n">unique_obj</span><span class="p">,</span> <span class="n">inverse_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Count occurrences of each unique row</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">inverse_indices</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">unique_obj</span><span class="p">))</span>

    <span class="n">n_unique</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">unique_obj</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">front_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_unique</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">max_fno</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Continue until enough solutions are sorted</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">front_no</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_sort</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">inverse_indices</span><span class="p">)):</span>
        <span class="n">max_fno</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_unique</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">front_no</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">dominated</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># Check domination by solutions in current front</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">front_no</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_fno</span><span class="p">:</span>
                        <span class="c1"># Check if solution j dominates solution i</span>
                        <span class="n">m_idx</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">while</span> <span class="n">m_idx</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">unique_obj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">unique_obj</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">m_idx</span><span class="p">]:</span>
                            <span class="n">m_idx</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="n">dominated</span> <span class="o">=</span> <span class="p">(</span><span class="n">m_idx</span> <span class="o">==</span> <span class="n">m</span><span class="p">)</span>

                        <span class="k">if</span> <span class="n">dominated</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">break</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">dominated</span><span class="p">:</span>
                    <span class="n">front_no</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_fno</span>

    <span class="c1"># Map back to original indices</span>
    <span class="n">front_no</span> <span class="o">=</span> <span class="n">front_no</span><span class="p">[</span><span class="n">inverse_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">front_no</span><span class="p">,</span> <span class="n">max_fno</span></div>



<div class="viewcode-block" id="crowding_distance">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.crowding_distance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">crowding_distance</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">front_no</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the crowding distance for a population of solutions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pop_obj : np.ndarray</span>
<span class="sd">        Objective value matrix, shape (n, m), where n is the number of</span>
<span class="sd">        solutions and m is the number of objectives</span>
<span class="sd">    front_no : np.ndarray, optional</span>
<span class="sd">        Non-dominated front number for each solution, shape (n,).</span>
<span class="sd">        If not provided, all solutions are assumed to belong to the same front.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    crowd_dis : np.ndarray</span>
<span class="sd">        Crowding distance for each solution, shape (n,).</span>
<span class="sd">        Boundary solutions are assigned infinite distance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pop_obj</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># If front_no is not provided, assume all solutions are in the same front</span>
    <span class="k">if</span> <span class="n">front_no</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">front_no</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="n">crowd_dis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># Get all fronts except inf</span>
    <span class="n">fronts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">front_no</span><span class="p">),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

    <span class="c1"># Calculate crowding distance for each front</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fronts</span><span class="p">:</span>
        <span class="c1"># Get indices of solutions in current front</span>
        <span class="n">front</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">front_no</span> <span class="o">==</span> <span class="n">f</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Skip if front has less than 2 solutions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">front</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">crowd_dis</span><span class="p">[</span><span class="n">front</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">continue</span>

        <span class="c1"># Get max and min values for each objective in this front</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">[</span><span class="n">front</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">fmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">[</span><span class="n">front</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Calculate crowding distance for each objective</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
            <span class="c1"># Sort solutions by i-th objective</span>
            <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pop_obj</span><span class="p">[</span><span class="n">front</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

            <span class="c1"># Boundary solutions get infinite crowding distance</span>
            <span class="n">crowd_dis</span><span class="p">[</span><span class="n">front</span><span class="p">[</span><span class="n">rank</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">crowd_dis</span><span class="p">[</span><span class="n">front</span><span class="p">[</span><span class="n">rank</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

            <span class="c1"># Calculate crowding distance for intermediate solutions</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">front</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fmin</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">crowd_dis</span><span class="p">[</span><span class="n">front</span><span class="p">[</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="o">+=</span> <span class="p">(</span>
                            <span class="p">(</span><span class="n">pop_obj</span><span class="p">[</span><span class="n">front</span><span class="p">[</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">pop_obj</span><span class="p">[</span><span class="n">front</span><span class="p">[</span><span class="n">rank</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">i</span><span class="p">])</span> <span class="o">/</span>
                            <span class="p">(</span><span class="n">fmax</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fmin</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span>

    <span class="k">return</span> <span class="n">crowd_dis</span></div>



<div class="viewcode-block" id="tournament_selection">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.tournament_selection">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">tournament_selection</span><span class="p">(</span>
        <span class="n">K</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="o">*</span><span class="n">fitness_arrays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">rng</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">Generator</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform tournament selection on a population.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    K : int</span>
<span class="sd">        Tournament size. If K &lt;= 1, selection is purely random with replacement.</span>
<span class="sd">    N : int</span>
<span class="sd">        Number of individuals to select</span>
<span class="sd">    *fitness_arrays : np.ndarray</span>
<span class="sd">        One or more arrays of fitness values. Higher fitness is considered better.</span>
<span class="sd">    rng : np.random.Generator, optional</span>
<span class="sd">        NumPy random number generator. If None, a new default RNG is created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    selected : np.ndarray</span>
<span class="sd">        Array of selected individual indices, shape (N,), dtype=int</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Convert inputs to 1D numpy arrays and validate lengths</span>
    <span class="n">fitnesss</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">fitness_arrays</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">fitnesss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">pop_size</span> <span class="o">=</span> <span class="n">fitnesss</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">rng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Purely random selection with replacement</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">fitnesss</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">pop_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ranks</span><span class="p">[</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">pop_size</span><span class="p">)</span>

        <span class="c1"># Sample K contestants for each of N tournaments (with replacement)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">integers</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop_size</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
        <span class="n">parent_ranks</span> <span class="o">=</span> <span class="n">ranks</span><span class="p">[</span><span class="n">parents</span><span class="p">]</span>
        <span class="n">winners_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">parent_ranks</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">selected</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">winners_pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">selected</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>



<div class="viewcode-block" id="selection_elit">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.selection_elit">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">selection_elit</span><span class="p">(</span>
        <span class="n">objs</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Elite selection for single-objective (optionally constrained) optimization.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objs : np.ndarray</span>
<span class="sd">        Objective values of the population (smaller is better), shape (N, 1)</span>
<span class="sd">    n : int</span>
<span class="sd">        Number of individuals to select</span>
<span class="sd">    cons : np.ndarray, optional</span>
<span class="sd">        Constraint violation values, each column is a constraint, shape (N, c).</span>
<span class="sd">        Default is None.</span>
<span class="sd">    epsilon : float, optional</span>
<span class="sd">        Threshold for constraint violations to be treated as feasible (default: 0)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    indices : np.ndarray</span>
<span class="sd">        Selected individual indices (0-based), shape (n,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">objs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">CVs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">cons</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">CVs</span><span class="p">[</span><span class="n">CVs</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">CVs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">objs</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">CVs</span><span class="o">.</span><span class="n">flatten</span><span class="p">()))</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">rank</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">indices</span></div>



<div class="viewcode-block" id="trim_excess_evaluations">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.trim_excess_evaluations">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">trim_excess_evaluations</span><span class="p">(</span>
        <span class="n">all_decs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">all_objs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">nt</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_nfes_per_task</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">nfes_per_task</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">all_cons</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim excess evaluations when nfes_per_task exceeds max_nfes_per_task</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    all_decs : List[List[np.ndarray]]</span>
<span class="sd">        Decision variables history for all tasks</span>
<span class="sd">    all_objs : List[List[np.ndarray]]</span>
<span class="sd">        Objective values history for all tasks</span>
<span class="sd">    nt : int</span>
<span class="sd">        Number of tasks</span>
<span class="sd">    max_nfes_per_task : List[int]</span>
<span class="sd">        Maximum evaluation budget per task</span>
<span class="sd">    nfes_per_task : List[int]</span>
<span class="sd">        Actual evaluations used per task</span>
<span class="sd">    all_cons : List[List[np.ndarray]], optional</span>
<span class="sd">        Constraint values history for all tasks</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    all_decs : List[List[np.ndarray]]</span>
<span class="sd">        Trimmed decision variables history</span>
<span class="sd">    all_objs : List[List[np.ndarray]]</span>
<span class="sd">        Trimmed objective values history</span>
<span class="sd">    nfes_per_task : List[int]</span>
<span class="sd">        Updated evaluation counts per task (after trimming)</span>
<span class="sd">    all_cons : List[List[np.ndarray]], optional</span>
<span class="sd">        Trimmed constraint values history (only if input all_cons is provided)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Deep copy to avoid modifying original data</span>
    <span class="n">all_decs_trimmed</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">all_decs</span><span class="p">)</span>
    <span class="n">all_objs_trimmed</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">all_objs</span><span class="p">)</span>
    <span class="n">nfes_per_task_updated</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nfes_per_task</span><span class="p">)</span>

    <span class="n">has_cons</span> <span class="o">=</span> <span class="n">all_cons</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">all_cons_trimmed</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">has_cons</span><span class="p">:</span>
        <span class="n">all_cons_trimmed</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">all_cons</span><span class="p">)</span>

    <span class="c1"># Process each task</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="p">):</span>
        <span class="c1"># Calculate excess evaluations</span>
        <span class="n">excess</span> <span class="o">=</span> <span class="n">nfes_per_task_updated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">max_nfes_per_task</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">excess</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Check if there are generations to trim</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">original_excess</span> <span class="o">=</span> <span class="n">excess</span>

            <span class="c1"># Get the last generation</span>
            <span class="n">last_gen_decs</span> <span class="o">=</span> <span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">last_gen_objs</span> <span class="o">=</span> <span class="n">all_objs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Check if excess is greater than or equal to all points in last generation</span>
            <span class="k">if</span> <span class="n">excess</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">last_gen_decs</span><span class="p">):</span>
                <span class="c1"># Remove entire last generation(s) if needed</span>
                <span class="k">while</span> <span class="n">excess</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">last_gen_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">excess</span> <span class="o">&gt;=</span> <span class="n">last_gen_size</span><span class="p">:</span>
                        <span class="c1"># Remove entire last generation</span>
                        <span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">all_objs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">has_cons</span> <span class="ow">and</span> <span class="n">all_cons_trimmed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">all_cons_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                        <span class="n">excess</span> <span class="o">-=</span> <span class="n">last_gen_size</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Trim partial last generation</span>
                        <span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>
                        <span class="n">all_objs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_objs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">has_cons</span> <span class="ow">and</span> <span class="n">all_cons_trimmed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">all_cons_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_cons_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>
                        <span class="n">excess</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Trim the last &#39;excess&#39; rows from the last generation</span>
                <span class="n">all_decs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_gen_decs</span><span class="p">[:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>
                <span class="n">all_objs_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_gen_objs</span><span class="p">[:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">has_cons</span> <span class="ow">and</span> <span class="n">all_cons_trimmed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">last_gen_cons</span> <span class="o">=</span> <span class="n">all_cons_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">all_cons_trimmed</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_gen_cons</span><span class="p">[:</span><span class="o">-</span><span class="n">excess</span><span class="p">]</span>

            <span class="c1"># Update nfes_per_task: subtract the number of trimmed evaluations</span>
            <span class="n">nfes_per_task_updated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="n">original_excess</span>

    <span class="c1"># Return results based on whether constraints are present</span>
    <span class="k">if</span> <span class="n">has_cons</span> <span class="ow">and</span> <span class="n">all_cons_trimmed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_decs_trimmed</span><span class="p">,</span> <span class="n">all_objs_trimmed</span><span class="p">,</span> <span class="n">nfes_per_task_updated</span><span class="p">,</span> <span class="n">all_cons_trimmed</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">all_decs_trimmed</span><span class="p">,</span> <span class="n">all_objs_trimmed</span><span class="p">,</span> <span class="n">nfes_per_task_updated</span></div>



<div class="viewcode-block" id="normalize">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.normalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">normalize</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;minmax&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
    <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize input data (arrays or matrices).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]]</span>
<span class="sd">        Supports the following input formats:</span>

<span class="sd">        - Single 1D array: [1, 2, 3]</span>
<span class="sd">        - Single 2D matrix: [[1,2], [3,4]]</span>
<span class="sd">        - List of multiple arrays/matrices: [[1,2,3], [4,5,6]] or [matrix1, matrix2]</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to normalize (only applies to 2D+ data), default is 0.</span>

<span class="sd">        - 0: Column-wise normalization (default, recommended for multi-objective optimization)</span>
<span class="sd">        - 1: Row-wise normalization</span>
<span class="sd">        - For 1D arrays, global normalization is always used</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Normalization method, default is &#39;minmax&#39;.</span>

<span class="sd">        - &#39;minmax&#39;: Min-max normalization, scales to [0, 1] (default)</span>
<span class="sd">        - &#39;zscore&#39;: Z-score normalization, mean=0, std=1</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normalized : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Normalized result (same format as input)</span>
<span class="sd">    stat1 : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Min values (minmax) or mean values (zscore)</span>
<span class="sd">    stat2 : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Max values (minmax) or std values (zscore)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minmax&#39;</span><span class="p">,</span> <span class="s1">&#39;zscore&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;minmax&#39; or &#39;zscore&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be 0 or 1&quot;</span><span class="p">)</span>

    <span class="c1"># Determine if input is a single array/matrix or a list of arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_single_input</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">single_input</span> <span class="o">=</span> <span class="n">is_single_input</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_input</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

    <span class="n">normalized</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stat1_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># min or mean</span>
    <span class="n">stat2_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># max or std</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">data_list</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">arr_ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>

        <span class="k">if</span> <span class="n">arr_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># 1D array: global normalization</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">stat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">stat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">range_val</span> <span class="o">=</span> <span class="n">stat2</span> <span class="o">-</span> <span class="n">stat1</span>
                <span class="k">if</span> <span class="n">range_val</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                    <span class="n">range_val</span> <span class="o">=</span> <span class="mf">1.0</span>
                <span class="n">arr_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">stat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">range_val</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># zscore</span>
                <span class="n">stat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">stat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
                <span class="n">stat2_safe</span> <span class="o">=</span> <span class="n">stat2</span> <span class="k">if</span> <span class="n">stat2</span> <span class="o">&gt;=</span> <span class="mf">1e-10</span> <span class="k">else</span> <span class="mf">1.0</span>
                <span class="n">arr_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">stat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">stat2_safe</span>

            <span class="n">normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_norm</span><span class="p">)</span>
            <span class="n">stat1_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat1</span><span class="p">)</span>
            <span class="n">stat2_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat2</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 2D+ array: normalize along specified axis</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="n">stat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">stat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">range_val</span> <span class="o">=</span> <span class="n">stat2</span> <span class="o">-</span> <span class="n">stat1</span>
                <span class="n">range_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">range_val</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">range_val</span><span class="p">)</span>
                <span class="n">arr_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">stat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">range_val</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># zscore</span>
                <span class="n">stat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">stat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="n">stat2_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">stat2</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">stat2</span><span class="p">)</span>
                <span class="n">arr_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">-</span> <span class="n">stat1</span><span class="p">)</span> <span class="o">/</span> <span class="n">stat2_safe</span>

            <span class="c1"># Remove keepdims dimension</span>
            <span class="n">stat1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stat1</span><span class="p">)</span>
            <span class="n">stat2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">stat2</span><span class="p">)</span>

            <span class="n">normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_norm</span><span class="p">)</span>
            <span class="n">stat1_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat1</span><span class="p">)</span>
            <span class="n">stat2_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stat2</span><span class="p">)</span>

    <span class="c1"># Return single result if input was single</span>
    <span class="k">if</span> <span class="n">single_input</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">normalized</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stat1_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">stat2_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">normalized</span><span class="p">,</span> <span class="n">stat1_list</span><span class="p">,</span> <span class="n">stat2_list</span></div>



<div class="viewcode-block" id="denormalize">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.denormalize">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">denormalize</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]],</span>
        <span class="n">stat1</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">stat2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]],</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;minmax&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Inverse normalization to restore original scale.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : Union[np.ndarray, List[float], List[np.ndarray], List[List[float]]]</span>
<span class="sd">        Normalized data (same format as normalize() output).</span>

<span class="sd">        - Single 1D array: [0, 0.25, 0.5, 0.75, 1]</span>
<span class="sd">        - Single 2D matrix: [[0, 0], [0.5, 0.5], [1, 1]]</span>
<span class="sd">        - List of multiple arrays/matrices</span>
<span class="sd">    stat1 : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Min values (minmax) or mean values (zscore) from normalize()</span>
<span class="sd">    stat2 : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Max values (minmax) or std values (zscore) from normalize()</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Must match the axis used in normalize(), default is 0.</span>

<span class="sd">        - 0: Column-wise normalization (default)</span>
<span class="sd">        - 1: Row-wise normalization</span>
<span class="sd">    method : str, optional</span>
<span class="sd">        Must match the method used in normalize(), default is &#39;minmax&#39;.</span>

<span class="sd">        - &#39;minmax&#39;: Inverse min-max normalization (default)</span>
<span class="sd">        - &#39;zscore&#39;: Inverse z-score normalization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    restored : Union[np.ndarray, List[np.ndarray]]</span>
<span class="sd">        Restored data in original scale (same format as input)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;minmax&#39;</span><span class="p">,</span> <span class="s1">&#39;zscore&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;method must be &#39;minmax&#39; or &#39;zscore&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be 0 or 1&quot;</span><span class="p">)</span>

    <span class="c1"># Determine if input is a single array/matrix or a list of arrays</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_single_input</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">single_input</span> <span class="o">=</span> <span class="n">is_single_input</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_input</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)]</span>
        <span class="n">stat1_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">stat1</span><span class="p">]</span>
        <span class="n">stat2_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">stat2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">stat1_list</span> <span class="o">=</span> <span class="n">stat1</span>
        <span class="n">stat2_list</span> <span class="o">=</span> <span class="n">stat2</span>

    <span class="n">restored</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">arr</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">stat1_list</span><span class="p">,</span> <span class="n">stat2_list</span><span class="p">):</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">arr_ndim</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Ensure at least 2D for unified processing</span>
        <span class="n">arr_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

        <span class="c1"># Prepare stats for broadcasting</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># For column-wise, stats should be (1, n_cols)</span>
            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># For row-wise, stats should be (n_rows, 1)</span>
            <span class="k">if</span> <span class="n">s1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">s1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">s2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
            <span class="c1"># Inverse min-max: x = norm * (max - min) + min</span>
            <span class="n">range_val</span> <span class="o">=</span> <span class="n">s2</span> <span class="o">-</span> <span class="n">s1</span>
            <span class="n">range_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">range_val</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">range_val</span><span class="p">)</span>
            <span class="n">arr_restored</span> <span class="o">=</span> <span class="n">arr_2d</span> <span class="o">*</span> <span class="n">range_val</span> <span class="o">+</span> <span class="n">s1</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># zscore</span>
            <span class="c1"># Inverse z-score: x = norm * std + mean</span>
            <span class="n">s2_safe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
            <span class="n">arr_restored</span> <span class="o">=</span> <span class="n">arr_2d</span> <span class="o">*</span> <span class="n">s2_safe</span> <span class="o">+</span> <span class="n">s1</span>

        <span class="c1"># Restore original dimensions</span>
        <span class="k">if</span> <span class="n">arr_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">arr_restored</span> <span class="o">=</span> <span class="n">arr_restored</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="n">restored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_restored</span><span class="p">)</span>

    <span class="c1"># Return single result if input was single</span>
    <span class="k">if</span> <span class="n">single_input</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">restored</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">restored</span></div>



<div class="viewcode-block" id="remove_duplicates">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.remove_duplicates">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">remove_duplicates</span><span class="p">(</span><span class="n">new_decs</span><span class="p">,</span> <span class="n">existing_decs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove duplicate solutions from new decision variables.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    new_decs : np.ndarray</span>
<span class="sd">        New decision variables to be filtered, shape (N, D)</span>
<span class="sd">    existing_decs : np.ndarray, optional</span>
<span class="sd">        Existing decision variables to check against, shape (M, D)</span>
<span class="sd">        If None, only remove duplicates within new_decs</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        Tolerance for duplicate detection (default: 1e-6)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    unique_decs : np.ndarray</span>
<span class="sd">        Unique decision variables, shape (K, D) where K &lt;= N</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">new_decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Step 1: Remove duplicates within new_decs</span>
    <span class="n">unique_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_decs</span><span class="p">):</span>
        <span class="n">dec_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">dec</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">dec_tuple</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dec_tuple</span><span class="p">)</span>
            <span class="n">unique_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="n">unique_decs</span> <span class="o">=</span> <span class="n">new_decs</span><span class="p">[</span><span class="n">unique_indices</span><span class="p">]</span>

    <span class="c1"># Step 2: Remove solutions already in existing_decs (if provided)</span>
    <span class="k">if</span> <span class="n">existing_decs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">existing_decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">final_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_decs</span><span class="p">):</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cdist</span><span class="p">(</span><span class="n">dec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">existing_decs</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">distances</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">final_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">final_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_decs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">unique_decs</span> <span class="o">=</span> <span class="n">unique_decs</span><span class="p">[</span><span class="n">final_indices</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">unique_decs</span></div>



<div class="viewcode-block" id="kmeans_clustering">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.kmeans_clustering">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">kmeans_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    K-means clustering using sklearn.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : np.ndarray</span>
<span class="sd">        Data points, shape (N, D)</span>
<span class="sd">    k : int</span>
<span class="sd">        Number of clusters</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    labels : np.ndarray</span>
<span class="sd">        Cluster labels for each point, shape (N,)</span>
<span class="sd">        Labels are integers in range [0, k-1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># If k &gt;= N, assign each point to its own cluster</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">labels</span></div>



<div class="viewcode-block" id="ibea_fitness">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.ibea_fitness">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ibea_fitness</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">kappa</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate fitness values for the population using IBEA indicator.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    objs : ndarray</span>
<span class="sd">        Objective values with shape (N, M), where N is the number of</span>
<span class="sd">        individuals and M is the number of objectives.</span>
<span class="sd">    kappa : float</span>
<span class="sd">        Fitness scaling factor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fitness : ndarray</span>
<span class="sd">        Fitness values for each individual with shape (N,).</span>
<span class="sd">    I : ndarray</span>
<span class="sd">        Indicator matrix with shape (N, N).</span>
<span class="sd">    C : ndarray</span>
<span class="sd">        Normalization constants with shape (N,).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Normalize objective values to [0, 1]</span>
    <span class="n">min_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">objs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">range_val</span> <span class="o">=</span> <span class="n">max_val</span> <span class="o">-</span> <span class="n">min_val</span>
    <span class="n">range_val</span><span class="p">[</span><span class="n">range_val</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">objs_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">objs</span> <span class="o">-</span> <span class="n">min_val</span><span class="p">)</span> <span class="o">/</span> <span class="n">range_val</span>

    <span class="c1"># Calculate indicator matrix (vectorized)</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">objs_norm</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">objs_norm</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Calculate normalization constants</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">C</span><span class="p">[</span><span class="n">C</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span>  <span class="c1"># Avoid division by zero</span>

    <span class="c1"># Calculate fitness</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">I</span> <span class="o">/</span> <span class="n">C</span> <span class="o">/</span> <span class="n">kappa</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">fitness</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">C</span></div>



<div class="viewcode-block" id="is_duplicate">
<a class="viewcode-back" href="../../../../api.html#ddmtolab.Methods.Algo_Methods.algo_utils.is_duplicate">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">is_duplicate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if position(s) x are duplicates in X or within themselves.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : np.ndarray</span>
<span class="sd">        Position(s) to check, shape (dim,) or (1, dim) or (n_points, dim)</span>
<span class="sd">    X : np.ndarray</span>
<span class="sd">        Existing positions, shape (n_samples, dim)</span>
<span class="sd">    epsilon : float</span>
<span class="sd">        Tolerance for duplicate detection</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool or list of bool</span>
<span class="sd">        - If x is single point: returns bool</span>
<span class="sd">        - If x contains multiple points: returns list of bool for each point</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure x is at least 2D</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Single point case: return bool</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Multiple points case: return list of bool</span>
        <span class="n">n_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n_points</span>

        <span class="c1"># Track which points in x are unique (not duplicate with any point checked so far)</span>
        <span class="n">unique_points</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># List of indices that are still considered unique</span>

        <span class="c1"># First pass: check against X</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dist_to_X</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dist_to_X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">):</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">unique_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">))</span>

        <span class="c1"># Second pass: check duplicates among unique x points</span>
        <span class="c1"># We&#39;ll build up a list of truly unique points</span>
        <span class="n">final_unique</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">unique_points</span><span class="p">:</span>
            <span class="n">is_unique</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Check against previously identified unique points</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">final_unique</span><span class="p">:</span>
                <span class="n">dist_ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">dist_ij</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="c1"># x[i] is duplicate of x[j]</span>
                    <span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">is_unique</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">break</span>

            <span class="k">if</span> <span class="n">is_unique</span><span class="p">:</span>
                <span class="n">final_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Jiangtao Shen.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>